<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>poorman on Random R Ramblings</title>
    <link>/tags/poorman/</link>
    <description>Recent content in poorman on Random R Ramblings</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Mon, 13 Apr 2020 20:12:00 -0500</lastBuildDate>
    
        <atom:link href="/tags/poorman/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>poorman: Select helpers, bug fixes and tests, tests, tests!</title>
      <link>/2020/04/13/poorman-select-helpers-bug-fixes-and-tests-tests-tests/</link>
      <pubDate>Mon, 13 Apr 2020 20:12:00 -0500</pubDate>
      
      <guid>/2020/04/13/poorman-select-helpers-bug-fixes-and-tests-tests-tests/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Hello all and welcome to another edition of the &lt;code&gt;poorman&lt;/code&gt; series of blog posts. In this series I am discussing my progress in writing a &lt;code&gt;base&lt;/code&gt; R equivalent of &lt;code&gt;dplyr&lt;/code&gt;. What’s nice about this series is that if you’re not into &lt;code&gt;poorman&lt;/code&gt; and would prefer just to use &lt;code&gt;dplyr&lt;/code&gt;, then that’s absolutely OK! By highlighting &lt;code&gt;poorman&lt;/code&gt; functionality, this series of blog posts simultaneously highlights &lt;code&gt;dplyr&lt;/code&gt; functionality too!&lt;/p&gt;
&lt;p&gt;Today I want to showcase some column selection helper features from the &lt;code&gt;tidyselect&lt;/code&gt; package - often used in conjunction with &lt;code&gt;dplyr&lt;/code&gt; - which I have finished now replicated within &lt;code&gt;poorman&lt;/code&gt;, of course using &lt;code&gt;base&lt;/code&gt; only. I’ll also discuss a little bit about what is happening in the background of &lt;code&gt;poorman&lt;/code&gt;’s development with regards to testing.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;select-helpers&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Select Helpers&lt;/h1&gt;
&lt;p&gt;The first official release version of &lt;code&gt;poorman&lt;/code&gt; (v 0.1.9) was the first version that I considered to contain all of the “core” functionality of &lt;code&gt;dplyr&lt;/code&gt;; everything from &lt;code&gt;select()&lt;/code&gt; to &lt;code&gt;group_by()&lt;/code&gt; and &lt;code&gt;summarise()&lt;/code&gt;. Now that that functionality is nailed down, it gives me time to focus of some of the smaller features of &lt;code&gt;dplyr&lt;/code&gt; and the wider &lt;code&gt;tidyverse&lt;/code&gt; and so over the last couple of weeks I have been working on adding the &lt;code&gt;tidyselect::select_helpers&lt;/code&gt; to &lt;code&gt;poorman&lt;/code&gt;. For those that are unaware, &lt;code&gt;select_helpers&lt;/code&gt; are a collection of functions that help the user to select variables based on their names. For example you may wish to select all columns which start with a certain prefix or maybe select columns matching a particular regular expression. Let’s take a look at some examples.&lt;/p&gt;
&lt;div id=&#34;selecting-columns-based-on-partial-column-names&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Selecting Columns Based On Partial Column Names&lt;/h2&gt;
&lt;p&gt;If your data contain lots of columns whose names share a similar structure, you can use partial matching by adding &lt;code&gt;starts_with()&lt;/code&gt;, &lt;code&gt;ends_with()&lt;/code&gt; or &lt;code&gt;contains()&lt;/code&gt; in your &lt;code&gt;select()&lt;/code&gt;/&lt;code&gt;relocate()&lt;/code&gt; statement.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(poorman, warn.conflicts = FALSE)
iris %&amp;gt;% select(starts_with(&amp;quot;Petal&amp;quot;), ends_with(&amp;quot;Width&amp;quot;)) %&amp;gt;% head()
#   Petal.Length Petal.Width Sepal.Width
# 1          1.4         0.2         3.5
# 2          1.4         0.2         3.0
# 3          1.3         0.2         3.2
# 4          1.5         0.2         3.1
# 5          1.4         0.2         3.6
# 6          1.7         0.4         3.9&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;reordering-columns&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Reordering Columns&lt;/h2&gt;
&lt;p&gt;The columns of the &lt;code&gt;iris&lt;/code&gt; dataset come in the following order.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;colnames(iris)
# [1] &amp;quot;Sepal.Length&amp;quot; &amp;quot;Sepal.Width&amp;quot;  &amp;quot;Petal.Length&amp;quot; &amp;quot;Petal.Width&amp;quot;  &amp;quot;Species&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But what if we wanted all of the “Width” columns at the start of this &lt;code&gt;data.frame&lt;/code&gt;? There are a couple of ways in which we can achieve this. Firstly, we can use &lt;code&gt;select()&lt;/code&gt; in combination with the select helper &lt;code&gt;everything()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;iris %&amp;gt;% select(&amp;quot;Petal.Width&amp;quot;, &amp;quot;Sepal.Width&amp;quot;, everything()) %&amp;gt;% head()
#   Petal.Width Sepal.Width Sepal.Length Petal.Length Species
# 1         0.2         3.5          5.1          1.4  setosa
# 2         0.2         3.0          4.9          1.4  setosa
# 3         0.2         3.2          4.7          1.3  setosa
# 4         0.2         3.1          4.6          1.5  setosa
# 5         0.2         3.6          5.0          1.4  setosa
# 6         0.4         3.9          5.4          1.7  setosa&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;poorman&lt;/code&gt; here first selects the columns “Petal.Width” and “Sepal.Width” before selecting everything else. This is great, but if your data contain a lot of columns containing “Width” then you will have to write out a lot of column names. Well this is where we can use &lt;code&gt;relocate()&lt;/code&gt; and the select helper &lt;code&gt;contains()&lt;/code&gt; to move those columns to the start of &lt;code&gt;iris&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;iris %&amp;gt;% relocate(contains(&amp;quot;Width&amp;quot;)) %&amp;gt;% head()
#   Sepal.Width Petal.Width Sepal.Length Petal.Length Species
# 1         3.5         0.2          5.1          1.4  setosa
# 2         3.0         0.2          4.9          1.4  setosa
# 3         3.2         0.2          4.7          1.3  setosa
# 4         3.1         0.2          4.6          1.5  setosa
# 5         3.6         0.2          5.0          1.4  setosa
# 6         3.9         0.4          5.4          1.7  setosa&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, &lt;code&gt;relocate()&lt;/code&gt; will move all selected columns to the start of the &lt;code&gt;data.frame&lt;/code&gt;. You can adjust this behaviour with the &lt;code&gt;.before&lt;/code&gt; and &lt;code&gt;.after&lt;/code&gt; parameters. Let’s move the “Petal” columns to appear after the “Species” column.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;iris %&amp;gt;% relocate(contains(&amp;quot;Petal&amp;quot;), .after = Species) %&amp;gt;% head()
#   Sepal.Length Sepal.Width Species Petal.Length Petal.Width
# 1          5.1         3.5  setosa          1.4         0.2
# 2          4.9         3.0  setosa          1.4         0.2
# 3          4.7         3.2  setosa          1.3         0.2
# 4          4.6         3.1  setosa          1.5         0.2
# 5          5.0         3.6  setosa          1.4         0.2
# 6          5.4         3.9  setosa          1.7         0.4&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;select-columns-using-a-regular-expression&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Select Columns Using a Regular Expression&lt;/h2&gt;
&lt;p&gt;The previous helper functions work with exact pattern matches. Let’s say you have similar patterns within your column names that are not quite the same, you can use regular expressions with the &lt;code&gt;matches()&lt;/code&gt; helper function to identify them. Here I will use the &lt;code&gt;mtcars&lt;/code&gt; dataset and look to extract all columns which start with a “w” or a “d” and end with a “t”.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% select(matches(&amp;quot;^[wd].*[t]$&amp;quot;)) %&amp;gt;% head()
#                   drat    wt
# Mazda RX4         3.90 2.620
# Mazda RX4 Wag     3.90 2.875
# Datsun 710        3.85 2.320
# Hornet 4 Drive    3.08 3.215
# Hornet Sportabout 3.15 3.440
# Valiant           2.76 3.460&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;the-select-helper-list&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The Select Helper List&lt;/h2&gt;
&lt;p&gt;We have seen a few examples of select helpers now available in &lt;code&gt;poorman&lt;/code&gt;. There are more, however, and the following list details each of them. Remember that these functions can be used to help users &lt;code&gt;select()&lt;/code&gt; and &lt;code&gt;relocate()&lt;/code&gt; columns within &lt;code&gt;data.frame&lt;/code&gt;s.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;starts_with()&lt;/code&gt;: Starts with a prefix.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ends_with()&lt;/code&gt;: Ends with a suffix.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;contains()&lt;/code&gt;: Contains a literal string.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;matches()&lt;/code&gt;: Matches a regular expression.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;num_range()&lt;/code&gt;: Matches a numerical range like &lt;code&gt;x01&lt;/code&gt;, &lt;code&gt;x02&lt;/code&gt;, &lt;code&gt;x03&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;all_of()&lt;/code&gt;: Matches variable names in a character vector. All names must be present, otherwise an out-of-bounds error is thrown.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;any_of()&lt;/code&gt;: Same as &lt;code&gt;all_of()&lt;/code&gt;, except that no error is thrown for names that don’t exist.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;everything()&lt;/code&gt;: Matches all variables.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;last_col()&lt;/code&gt;: Select last variable, possibly with an offset.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;docker&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Docker&lt;/h1&gt;
&lt;p&gt;There was a request on Twitter to put together a Docker image for &lt;code&gt;poorman&lt;/code&gt;. This has now been done and can be seen on &lt;a href=&#34;https://hub.docker.com/repository/docker/nathaneastwood/poorman&#34;&gt;Dockerhub&lt;/a&gt;. This means if you have Docker installed, you can run a containerised version of &lt;code&gt;poorman&lt;/code&gt; easily with the following line of code.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;docker run --rm -it nathaneastwood/poorman&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;test-test-test&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Test, Test, Test!&lt;/h1&gt;
&lt;p&gt;Since the &lt;a href=&#34;https://nathaneastwood.github.io/2020/04/01/poorman-first-release-of-a-base-r-dplyr-clone/&#34;&gt;last release&lt;/a&gt; of &lt;code&gt;poorman&lt;/code&gt; (v 0.1.9) to CRAN, I have been working on a few bugs that I and other users of the package had identified. I’m happy to say that these have now been squashed and the &lt;a href=&#34;https://github.com/nathaneastwood/poorman/issues&#34;&gt;issues list&lt;/a&gt; is looking very empty. As a brief overview, the following problems are now fixed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mutate()&lt;/code&gt; column creations are immediately available, e.g. &lt;code&gt;mtcars %&amp;gt;% mutate(mpg2 = mpg * 2, mpg4 = mpg2 * 2)&lt;/code&gt; will create columns named &lt;code&gt;mpg2&lt;/code&gt; and &lt;code&gt;mpg4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group_by()&lt;/code&gt; groups now persist in selections, e.g. &lt;code&gt;mtcars %&amp;gt;% group_by(am) %&amp;gt;% select(mpg)&lt;/code&gt; will return &lt;code&gt;am&lt;/code&gt; and &lt;code&gt;mpg&lt;/code&gt; columns&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slice()&lt;/code&gt; now duplicates rows, e.g. &lt;code&gt;mtcars %&amp;gt;% slice(2, 2, 2)&lt;/code&gt; will return row 2 three times&lt;/li&gt;
&lt;li&gt;&lt;code&gt;summarize()&lt;/code&gt; is now exported&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;dplyr&lt;/code&gt; is a very well known and extremely well developed package. In order for &lt;code&gt;poorman&lt;/code&gt; to have any credibility, it needs to work correctly. Therefore a large amount of effort and energy has gone into testing &lt;code&gt;poorman&lt;/code&gt; to ensure it produces the results one would expect. Since adding all of the new features and bug fixes described in this blog, &lt;code&gt;poorman&lt;/code&gt; has surpassed 100 tests!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tinytest::test_all()                                    
# Running test_arrange.R................    5 tests OK
# Running test_filter.R.................    6 tests OK
# Running test_groups.R.................    5 tests OK
# Running test_joins_filter.R...........    4 tests OK
# Running test_joins.R..................    7 tests OK
# Running test_mutate.R.................    6 tests OK
# Running test_pull.R...................    6 tests OK
# Running test_relocate.R...............    6 tests OK
# Running test_rename.R.................    4 tests OK
# Running test_rownames.R...............    2 tests OK
# Running test_select_helpers.R.........   25 tests OK
# Running test_select.R.................   13 tests OK
# Running test_slice.R..................    5 tests OK
# Running test_summarise.R..............    6 tests OK
# Running test_transmute.R..............    3 tests OK
# Running test_utils.R..................    1 tests OK
# [1] &amp;quot;All ok, 104 results&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This also means that the package coverage is extremely high.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;covr::package_coverage()                                                                                        #
# poorman Coverage: 97.87%
# R/utils.R: 80.00%
# R/group.R: 90.91%
# R/joins.R: 92.86%
# R/arrange.R: 100.00%
# R/filter.R: 100.00%
# R/init.R: 100.00%
# R/joins_filtering.R: 100.00%
# R/mutate.R: 100.00%
# R/pipe.R: 100.00%
# R/pull.R: 100.00%
# R/relocate.R: 100.00%
# R/rename.R: 100.00%
# R/rownames.R: 100.00%
# R/select_helpers.R: 100.00%
# R/select.R: 100.00%
# R/slice.R: 100.00%
# R/summarise.R: 100.00%
# R/transmute.R: 100.00%&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I hope this gives users of &lt;code&gt;poorman&lt;/code&gt; that extra confidence when using the package. I have now submitted this updated version of &lt;code&gt;poorman&lt;/code&gt; to CRAN and I am just waiting on their feedback so hopefully in the coming days it will be available. Watch this space!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>poorman: The Selectificator 2000!</title>
      <link>/2020/04/13/poorman-the-selectificator-2000/</link>
      <pubDate>Mon, 13 Apr 2020 20:12:00 -0500</pubDate>
      
      <guid>/2020/04/13/poorman-the-selectificator-2000/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Welcome to my series of blog posts about my data manipulation package, &lt;code&gt;{poorman}&lt;/code&gt;. For those of you that don’t know, &lt;code&gt;{poorman}&lt;/code&gt; is aiming to be a replication of &lt;code&gt;{dplyr}&lt;/code&gt; but using only &lt;code&gt;{base}&lt;/code&gt; R, and therefore be completely dependency free. What’s nice about this series is that if you’re not into &lt;code&gt;{poorman}&lt;/code&gt; and would prefer just to use &lt;code&gt;{dplyr}&lt;/code&gt;, then that’s absolutely OK! By highlighting &lt;code&gt;{poorman}&lt;/code&gt; functionality, this series of blog posts simultaneously highlights &lt;code&gt;{dplyr}&lt;/code&gt; functionality too! However I also describe how I developed the internals of &lt;code&gt;{poorman}&lt;/code&gt;, often highlighting useful &lt;code&gt;{base}&lt;/code&gt; R tips and tricks.&lt;/p&gt;
&lt;p&gt;I recently released v0.2.0 of &lt;code&gt;{poorman}&lt;/code&gt; which you can install from &lt;a href=&#34;https://cran.r-project.org/web/packages/poorman/&#34;&gt;CRAN&lt;/a&gt; and so today I am going to talk about my progress in expanding the flexibility of the &lt;code&gt;select()&lt;/code&gt; function. But I’m not just going to show you what it can do, I am going to show you how. If you’re interested in learning a little bit about non-standard evaluation in R then be sure to read on.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-selectificator-1000&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The Selectificator 1000&lt;/h1&gt;
&lt;p&gt;Before v0.2.0, &lt;code&gt;{poorman}&lt;/code&gt; was using a form of non-standard evaluation which converts function inputs to character strings and then uses those to figure out which columns to select. Specifically, &lt;code&gt;{poorman}&lt;/code&gt; includes the following helper function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;deparse_dots &amp;lt;- function(...) {
  vapply(substitute(...()), deparse, NA_character_)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is an unexported function since it is not user facing but you can find it in the code on GitHub &lt;a href=&#34;https://github.com/nathaneastwood/poorman/blob/master/R/utils.R#L1&#34;&gt;here&lt;/a&gt;. Let’s dig into what this function does a little, but first we will define a temporary function to show by example.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dummy_select &amp;lt;- function(...) {
  deparse_dots(...)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now of course in the real &lt;code&gt;select()&lt;/code&gt; function, &lt;code&gt;select()&lt;/code&gt; takes both data (passed to &lt;code&gt;.data&lt;/code&gt;) and column names (passed to &lt;code&gt;...&lt;/code&gt;) as inputs and then returns a subset of the data object containing only those columns. In our temporary function, we are just interested in the evaluation of the column names. So let’s try it out.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dummy_select(x, y)
# [1] &amp;quot;x&amp;quot; &amp;quot;y&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we passed two objects, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; which are intended to represent our column names. These objects are in fact symbols which we would expect to be evaluated, but they weren’t; they are instead turned into character strings. This is thanks to the &lt;code&gt;deparse()&lt;/code&gt; and &lt;code&gt;substitute()&lt;/code&gt; combination. &lt;code&gt;deparse_dots()&lt;/code&gt; first uses &lt;code&gt;substitute()&lt;/code&gt; to return the unevaluated expression (in our case &lt;code&gt;...()&lt;/code&gt;) and substitutes any variables bound in the environment (here &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;). &lt;code&gt;deparse_dots()&lt;/code&gt; then loops over each of these inputs and deparses them. From the help page, &lt;code&gt;?deparse&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Turn unevaluated expressions into character strings.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So now we have our function column inputs as character strings. This is a good start as we can now match on those character strings with the column names of our data (&lt;code&gt;match(deparse_dots(...), colnames(.data))&lt;/code&gt;) to get the integer column positions of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. But what if the user inputs, for example, an integer?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dummy_select(1, 3, 5)
# [1] &amp;quot;1&amp;quot; &amp;quot;3&amp;quot; &amp;quot;5&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This now poses a problem. Does the user here mean that they want the first, third and fifth columns returned? Or do they mean that there are columns within their &lt;code&gt;data.frame&lt;/code&gt; called “1”, “3” and “5” - which aren’t necessarily in the first, third and fifth positions - and those are the columns they would like? So the problem with this approach is that when everything is converted to characters, it is almost impossible to know whether the user input to the function is a column name, a column integer position or a function like a &lt;a href=&#34;https://nathaneastwood.github.io/2020/04/13/poorman-select-helpers-bug-fixes-and-tests-tests-tests/&#34;&gt;select helper&lt;/a&gt;, with any degree of certainty. The function has to &lt;code&gt;try()&lt;/code&gt; certain things by making certain assumptions and of course making an assumption makes…well, you’ve heard the saying.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-selectificator-2000&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The Selectificator 2000&lt;/h1&gt;
&lt;p&gt;This is where the upgrades to the &lt;code&gt;poorman::select()&lt;/code&gt; function come in. As a user I want to be able to pass integers, numerics, character strings, symbols and even functions to be interpreted by the &lt;code&gt;select()&lt;/code&gt; function correctly and return the columns I desire. This is where the next line of code - which is absolutely brilliant - comes in.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eval(substitute(alist(...)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s break this function down and see what it does. We will work with a function and build it up bit by bit.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dummy_select &amp;lt;- function(...) {
  alist(...)
}
dummy_select(x, y)
# [[1]]
# ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok, not so exciting, right? What about if we wrap this in substitute?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dummy_select &amp;lt;- function(...) {
  substitute(alist(...))
}
dummy_select(x, y)
# alist(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can see that we have managed to pass in our inputs but they seem to be wrapped in an unevaluated call to &lt;code&gt;alist()&lt;/code&gt;, so let’s try and evaluate it.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dummy_select &amp;lt;- function(...) {
  eval(substitute(alist(...)))
}
dummy_select(x, y)
# [[1]]
# x
# 
# [[2]]
# y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Perfect! Now we have our unevaluated function inputs stored in a list. But what is so great about that? Well, let’s take a look at the structure of this output.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(dummy_select(x, y))
# List of 2
#  $ : symbol x
#  $ : symbol y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we can see that our inputs have been stored as their appropriate class; symbols! As a matter of fact, this occurs no matter what we use as our inputs.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(dummy_select(1L, 2, &amp;quot;x&amp;quot;, y, starts_with(&amp;quot;R&amp;quot;)))
# List of 5
#  $ : int 1
#  $ : num 2
#  $ : chr &amp;quot;x&amp;quot;
#  $ : symbol y
#  $ : language starts_with(&amp;quot;R&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is fantastic. What this means is that we can now define functionality that can handle each of the separate types we typically expect being used in a call to &lt;code&gt;select()&lt;/code&gt;. All of this magic is owed to the &lt;code&gt;alist()&lt;/code&gt; function, let’s take a look at the documentation.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;alist&lt;/code&gt; handles its arguments as if they described function arguments. So the values are not evaluated, and tagged arguments with no value are allowed whereas &lt;code&gt;list&lt;/code&gt; simply ignores them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So if we had used the &lt;code&gt;list()&lt;/code&gt; function, it would have attempted to evaluate our inputs to the &lt;code&gt;dummy_select()&lt;/code&gt; function whereas &lt;code&gt;alist()&lt;/code&gt; does not - it stores them as unevaluated objects.&lt;/p&gt;
&lt;p&gt;Now, this starts to get really interesting when we start to take a look at the &lt;code&gt;language&lt;/code&gt; inputs. When using &lt;code&gt;dplyr::select()&lt;/code&gt;, the user is able to select columns in a number of ways. Let’s take a look at some of them and what the structure of those look like.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(dummy_select(!w, x:y, -z))
# List of 3
#  $ : language !w
#  $ : language x:y
#  $ : language -z&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So selecting columns through the use of an exclamation mark (negation), a colon or a minus sign actually gives us a &lt;code&gt;language&lt;/code&gt; object. Ok, so what? What is so special about this? Well what makes this so useful to us is how we can interact with the objects. We can actually access parts of the &lt;code&gt;language&lt;/code&gt; object, much in the same way we do with a &lt;code&gt;list()&lt;/code&gt;. Let’s take a look.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;obj &amp;lt;- dummy_select(x:y)
obj[[1]][1]
# `:`()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So operators are actually functions. In fact, in R, everything is an object and we interact with those objects using functions, so this makes sense. Let’s look a bit deeper into this object.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;obj[[1]][[1]]
# `:`
obj[[1]][[2]]
# x
obj[[1]][[3]]
# y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So our function input, &lt;code&gt;x:y&lt;/code&gt;, can be broken down into it’s individual components. We know that the components are made up of the colon function as well as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, but what is the structure of these final two components?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(obj[[1]][[2]])
#  symbol x
str(obj[[1]][[3]])
#  symbol y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;They are symbols! So now we can handle these much in the same way as we did with the symbol inputs in the first instance, because remember, just passing &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; to our &lt;code&gt;dummy_select()&lt;/code&gt; function returned a symbol.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(dummy_select(x, y))
# List of 2
#  $ : symbol x
#  $ : symbol y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So there you have it! This is how you, as the user, are now able to perform &lt;code&gt;select()&lt;/code&gt; calls with &lt;code&gt;{poorman}&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(poorman, warn.conflicts = FALSE)
mtcars %&amp;gt;%
  select(drat, mpg:hp, starts_with(&amp;quot;g&amp;quot;), everything()) %&amp;gt;%
  head()
#                   drat  mpg cyl disp  hp gear    wt  qsec vs am carb
# Mazda RX4         3.90 21.0   6  160 110    4 2.620 16.46  0  1    4
# Mazda RX4 Wag     3.90 21.0   6  160 110    4 2.875 17.02  0  1    4
# Datsun 710        3.85 22.8   4  108  93    4 2.320 18.61  1  1    1
# Hornet 4 Drive    3.08 21.4   6  258 110    3 3.215 19.44  1  0    1
# Hornet Sportabout 3.15 18.7   8  360 175    3 3.440 17.02  0  0    2
# Valiant           2.76 18.1   6  225 105    3 3.460 20.22  1  0    1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;This post has taken a look at two separate non-standard evaluation approaches - using nothing but &lt;code&gt;{base}&lt;/code&gt; - deployed within the &lt;code&gt;{poorman}&lt;/code&gt; package. We have seen how to break down &lt;code&gt;language&lt;/code&gt; objects to pick out key pieces of information from them. We also saw how to determine the object types of function inputs and why this is important to consider. In particular, this showed how I was able to transform the &lt;code&gt;select()&lt;/code&gt; function into the omega selectificator function…of doom.&lt;/p&gt;
&lt;p&gt;As this blog post is quite long, I haven’t gone into any further details of the internals of &lt;code&gt;{poorman}&lt;/code&gt; however if you are interested in taking a closer look at how I handle the different input types, you can see the code on the relevant &lt;code&gt;{poorman}&lt;/code&gt; &lt;a href=&#34;https://github.com/nathaneastwood/poorman/blob/master/R/select_positions.R&#34;&gt;GitHub page&lt;/a&gt;. &lt;code&gt;{poorman}&lt;/code&gt; is still a work in progress but as you can see, it already has a lot of functionality you know and love from &lt;code&gt;{dplyr}&lt;/code&gt; so if you are working on a new project and don’t want to have to deal with dependency management, especially if you are sharing work with colleagues, why not give &lt;code&gt;{poorman}&lt;/code&gt; a try?&lt;/p&gt;
&lt;p&gt;If you’d like to show your support for &lt;code&gt;{poorman}&lt;/code&gt;, please consider giving the package a &lt;a href=&#34;https://github.com/nathaneastwood/poorman/stargazers&#34;&gt;Star on Github&lt;/a&gt; as it gives me that boost of dopamine needed to continue development.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>poorman: First Release of a base R dplyr Clone</title>
      <link>/2020/04/01/poorman-first-release-of-a-base-r-dplyr-clone/</link>
      <pubDate>Wed, 01 Apr 2020 20:12:00 -0500</pubDate>
      
      <guid>/2020/04/01/poorman-first-release-of-a-base-r-dplyr-clone/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The first official release of &lt;code&gt;poorman&lt;/code&gt; (v 0.1.9) is &lt;a href=&#34;https://cran.r-project.org/web/packages/poorman/index.html&#34;&gt;now on CRAN&lt;/a&gt;! You can now install &lt;code&gt;poorman&lt;/code&gt; directly from CRAN with the following code:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;poorman&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this blog post I want to address some common questions that I have received since I started writing the package.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;what-is-poorman&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What is &lt;code&gt;poorman&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;poorman&lt;/code&gt; is a package that unapologetically attempts to recreate the &lt;code&gt;dplyr&lt;/code&gt; API in a dependency free way using only &lt;code&gt;base&lt;/code&gt; R. &lt;code&gt;poorman&lt;/code&gt; is still under development and doesn’t have all of &lt;code&gt;dplyr&lt;/code&gt;’s functionality but what I would consider the “core” functionality is included. The idea behind &lt;code&gt;poorman&lt;/code&gt; is that a user should be able to take their &lt;code&gt;dplyr&lt;/code&gt; based script and run it using &lt;code&gt;poorman&lt;/code&gt; without any hiccups.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;so-what-does-poorman-include&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;So what does &lt;code&gt;poorman&lt;/code&gt; include?&lt;/h1&gt;
&lt;p&gt;In this first official release, &lt;code&gt;poorman&lt;/code&gt; includes copies of the key &lt;code&gt;dplyr&lt;/code&gt; functions.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select(), rename(), pull(), relocate(), mutate(), transmute(), arrange()
filter(), slice()
summarise() / summarize()
group_by(), ungroup()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;poorman&lt;/code&gt; also includes the join functionality.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inner_join(), left_join(), right_join(), full_join()
anti_join(), semi_join()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally &lt;code&gt;poorman&lt;/code&gt; also includes its own version of the pipe so you do not need to load or install &lt;code&gt;magrittr&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%&amp;gt;%&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More functionality is being developed and will be added in time.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;why-develop-poorman&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Why develop &lt;code&gt;poorman&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;This is probably the most common question; why bother developing &lt;code&gt;poorman&lt;/code&gt; when &lt;code&gt;dplyr&lt;/code&gt; already exists. Well there are actually several reasons why I decided to develop it. The most important reason to me though is quite simply because I can. &lt;code&gt;poorman&lt;/code&gt; started out as a personal challenge and a bit of fun. Also as a freelance R developer, it is good to build up my portfolio of open source code that I can show to potential clients.&lt;/p&gt;
&lt;p&gt;Another reason for developing &lt;code&gt;poorman&lt;/code&gt; is I wanted to challenge a common misconception that &lt;code&gt;base&lt;/code&gt; R is not as powerful, or as good, or as useful as &lt;code&gt;dplyr&lt;/code&gt;. Too often I see and hear comments belittling &lt;code&gt;base&lt;/code&gt; R and as a user of the language for over 10 years now - well before the inception of &lt;code&gt;dplyr&lt;/code&gt; - I find this idea very worrying. &lt;code&gt;poorman&lt;/code&gt;’s package start up message is quite poignant in this regard.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I’d seen my father. He was a poor man, and I watched him do astonishing things. - Sidney Poitier&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Finally, I have a natural joy of teaching. Writing &lt;code&gt;poorman&lt;/code&gt; gives me a platform to hopefully show useRs two key aspects of R programming in &lt;code&gt;base&lt;/code&gt;; common data manipulation tasks; and non-standard evaulation.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;but-why-not-just-use-dplyr&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;But why not just use &lt;code&gt;dplyr&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;Let’s be honest, the &lt;code&gt;tidyverse&lt;/code&gt; is a fantastic set of packages which have transformed the face of data analysis in R, and &lt;code&gt;dplyr&lt;/code&gt; is arguably one of the most important packages within the &lt;code&gt;tidyverse&lt;/code&gt;. The API is in my opinion very easy to learn and use.&lt;/p&gt;
&lt;p&gt;Being a part of the &lt;code&gt;tidyverse&lt;/code&gt;, however, means that &lt;code&gt;dplyr&lt;/code&gt; comes with a large number of dependencies that users must also install which is often seen as a disadvantage to using the &lt;code&gt;tidyverse&lt;/code&gt;. Disadvantages of dependencies have been &lt;a href=&#34;http://dirk.eddelbuettel.com/blog/2018/02/28/#017_dependencies&#34;&gt;written about&lt;/a&gt; before and so I won’t go into detail here. However what I will say is that the user may not have a need for additional parts of the &lt;code&gt;tidyverse&lt;/code&gt; and so may not wish to have to install multiple packages to use one or two functions.&lt;/p&gt;
&lt;p&gt;Some of these dependencies are very useful of course, allowing expansion into other areas such as accessing Spark instances and databases using the same API the user already knows. This is great and if you are using these additional tools then I absolutely recommend that you choose &lt;code&gt;dplyr&lt;/code&gt; over &lt;code&gt;poorman&lt;/code&gt;. However if you don’t need the extra dependencies and functionality that comes with the wider &lt;code&gt;tidyverse&lt;/code&gt; then maybe consider giving the lightweight &lt;code&gt;poorman&lt;/code&gt; a go.&lt;/p&gt;
&lt;p&gt;Finally a point on installation times, &lt;code&gt;poorman&lt;/code&gt; takes roughly six seconds to install. If you’ve ever had to install or upgrade &lt;code&gt;dplyr&lt;/code&gt; or the &lt;code&gt;tidyverse&lt;/code&gt;, you’ll recognise that this is very fast.&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;/img/poorman_installation.gif&#34; /&gt;
&lt;/center&gt;
&lt;/div&gt;
&lt;div id=&#34;why-the-name-poorman&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Why the name &lt;code&gt;poorman&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;As I have already mentioned, I have seen comments in the past pertaining to R’s worthlessness without the &lt;code&gt;tidyverse&lt;/code&gt; and so the name &lt;code&gt;poorman&lt;/code&gt; is a subtle play on the the idea that you must be a “poor man” if you use &lt;code&gt;base&lt;/code&gt;. The irony of course is that I have managed to recreate - quite easily - the key parts of the &lt;code&gt;dplyr&lt;/code&gt; API using only &lt;code&gt;base&lt;/code&gt; R.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;why-not-use-data.table-for-the-backend&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Why not use &lt;code&gt;data.table&lt;/code&gt; for the backend?&lt;/h1&gt;
&lt;p&gt;Because I wanted to build something that was completely dependency free and adding &lt;code&gt;data.table&lt;/code&gt; as an &lt;code&gt;Import&lt;/code&gt; adds a dependency.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;but-doesnt-poorman-have-dependencies&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;But doesn’t &lt;code&gt;poorman&lt;/code&gt; have dependencies?&lt;/h1&gt;
&lt;p&gt;To answer this, we need to define what we mean by “dependency free”. &lt;code&gt;poorman&lt;/code&gt; does have some dependencies but they are for development purposes only and are therefore listed in the &lt;code&gt;Suggests&lt;/code&gt; part of the &lt;code&gt;DESCRIPTION&lt;/code&gt; file. Thus when a user installs the package, these dependencies are only ever installed if they are explicitly requested. However, &lt;code&gt;poorman&lt;/code&gt; doesn’t have any dependencies that users of the package need to install in order to use its functionality. I use these dependency packages to help me develop more easily. Therefore &lt;code&gt;poorman&lt;/code&gt; isn’t a truly “dependency free” like &lt;code&gt;data.table&lt;/code&gt; is, but it is dependency free for its intended users.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;So if you find yourself needing a dependency free data manipulation package that follows the &lt;code&gt;dplyr&lt;/code&gt; API with short installation times then give &lt;code&gt;poorman&lt;/code&gt; a try. Equally if you find any issues, please submit an issue to &lt;a href=&#34;https://github.com/nathaneastwood/poorman/issues&#34;&gt;&lt;code&gt;GitHub&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>poorman: Replicating dplyr&#39;s Join and Filter Join Functions with base R</title>
      <link>/2020/03/08/poorman-replicating-dplyrs-join-and-filter-join-functions-with-base-r/</link>
      <pubDate>Sun, 08 Mar 2020 20:12:00 -0500</pubDate>
      
      <guid>/2020/03/08/poorman-replicating-dplyrs-join-and-filter-join-functions-with-base-r/</guid>
      <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In my &lt;a href=&#34;https://nathaneastwood.github.io/2020/02/27/building-a-base-dplyr-with-primitives-grouped-operations-pipes-and-more/&#34;&gt;last post&lt;/a&gt; I discussed performing split-apply-combine operations on R &lt;code&gt;data.frame&lt;/code&gt;s and how this functionality was used within &lt;a href=&#34;https://github.com/nathaneastwood/poorman&#34;&gt;&lt;code&gt;poorman&lt;/code&gt;&lt;/a&gt; - a &lt;code&gt;base&lt;/code&gt; R replica of &lt;code&gt;dplyr&lt;/code&gt;. In this post I’d like to talk about replicating &lt;code&gt;dplyr&lt;/code&gt;’s join and filter join functionality, again using nothing but &lt;code&gt;base&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;joins&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Joins&lt;/h1&gt;
&lt;p&gt;First of all, let’s set up some data to use for our examples. Here I create two &lt;code&gt;data.frame&lt;/code&gt;s; one containing heights associated with names and IDs; the second containing weights also associated with some names and IDs. Some of these ID and name combinations are common to both tables (e.g. &lt;code&gt;c(&#34;id&#34; = 5, &#34;name&#34; = &#34;C&#34;)&lt;/code&gt;) but other IDs are unique to one table or the other (e.g. &lt;code&gt;c(&#34;id&#34; = 1, &#34;name&#34; = &#34;A&#34;)&lt;/code&gt;).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that sometimes a list of elements (here name and ID) are somtimes referred to as a tuple.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table1 &amp;lt;- data.frame(
  id = c(1, 3, 5, 7, 9),
  name = LETTERS[1:5],
  height = c(1, 2, 2, 2, 2),
  stringsAsFactors = FALSE
)
table1
#   id name height
# 1  1    A      1
# 2  3    B      2
# 3  5    C      2
# 4  7    D      2
# 5  9    E      2
table2 &amp;lt;- data.frame(
  id = c(2, 4, 5, 7),
  name = LETTERS[1:4],
  weight = c(2, 3, 4, 5),
  stringsAsFactors = FALSE
)
table2
#   id name weight
# 1  2    A      2
# 2  4    B      3
# 3  5    C      4
# 4  7    D      5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When working with data such as this, we may wish to join these two tables together such that we can more easily use data from both. In &lt;code&gt;base&lt;/code&gt;, the function we use for joining tables together is called &lt;code&gt;merge()&lt;/code&gt;. We will see how we can use this one function to perform inner, left, right and full joins.&lt;/p&gt;
&lt;div id=&#34;inner-join&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Inner Join&lt;/h2&gt;
&lt;p&gt;An inner join selects records that have matching values in both tables within the columns we are joining by, returning all columns. For &lt;code&gt;table1&lt;/code&gt; and &lt;code&gt;table2&lt;/code&gt;, we will be joining the tables by &lt;code&gt;&#34;id&#34;&lt;/code&gt; and &lt;code&gt;&#34;name&#34;&lt;/code&gt; since these are the common columns between both tables.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that depending on your circumstance you may not wish to join on all common columns. For example you may have two tables that have columns with the same name but actually contain different data.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When we perform the inner join therefore, we will expect a &lt;code&gt;data.frame&lt;/code&gt; containing the records &lt;code&gt;c(&#34;id&#34; = 5, &#34;name&#34; = &#34;C&#34;)&lt;/code&gt; and &lt;code&gt;c(&#34;id&#34; = 7, &#34;name&#34; = &#34;D&#34;)&lt;/code&gt; since these records exist in both tables.&lt;/p&gt;
&lt;p&gt;To perform an inner join, we use the &lt;code&gt;merge()&lt;/code&gt; function with no additional parameters, giving the two tables to merge.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;merge(x = table1, y = table2)
#   id name height weight
# 1  5    C      2      4
# 2  7    D      2      5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When performing a join, we typically specify which columns we would like to join on. &lt;code&gt;merge()&lt;/code&gt; is helpful in that it works out the common columns between the datasets with the following command.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;by &amp;lt;- intersect(names(table1), names(table2))
by
# [1] &amp;quot;id&amp;quot;   &amp;quot;name&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we wanted, we could pass the column names explicitly.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;merge(x = table1, y = table2, by = c(&amp;quot;id&amp;quot;, &amp;quot;name&amp;quot;))
#   id name height weight
# 1  5    C      2      4
# 2  7    D      2      5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;code&gt;poorman&lt;/code&gt;, we can use the &lt;code&gt;inner_join()&lt;/code&gt; function to perform this type of join.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table1 %&amp;gt;% inner_join(table2)
# Joining, by = c(&amp;quot;id&amp;quot;, &amp;quot;name&amp;quot;)
#   id name height weight
# 1  5    C      2      4
# 2  7    D      2      5&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;left-join&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Left Join&lt;/h2&gt;
&lt;p&gt;A left join will include all rows from &lt;code&gt;table1&lt;/code&gt; regardless of whether or not there is a matching record in &lt;code&gt;table2&lt;/code&gt;. For those records which do not have a match, the left join will leave the cells as &lt;code&gt;NA&lt;/code&gt; values. In &lt;code&gt;base&lt;/code&gt;, we perform this type of join with the &lt;code&gt;merge()&lt;/code&gt; function, specifying &lt;code&gt;all.x = TRUE&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;merge(x = table1, y = table2, all.x = TRUE)
#   id name height weight
# 1  1    A      1     NA
# 2  3    B      2     NA
# 3  5    C      2      4
# 4  7    D      2      5
# 5  9    E      2     NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;code&gt;poorman&lt;/code&gt;, this type of join can be performed with &lt;code&gt;left_join()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table1 %&amp;gt;% left_join(table2)
# Joining, by = c(&amp;quot;id&amp;quot;, &amp;quot;name&amp;quot;)
#   id name height weight
# 1  1    A      1     NA
# 2  3    B      2     NA
# 3  5    C      2      4
# 4  7    D      2      5
# 5  9    E      2     NA&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;right-join&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Right Join&lt;/h2&gt;
&lt;p&gt;A right join is the opposite of a left join. Here, the &lt;code&gt;merge()&lt;/code&gt; function returns all rows from &lt;code&gt;table2&lt;/code&gt; and the matched rows from &lt;code&gt;table1&lt;/code&gt;; again filling any blank cells with &lt;code&gt;NA&lt;/code&gt;. This time, we specify &lt;code&gt;all.y = TRUE&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;merge(x = table1, y = table2, all.y = TRUE)
#   id name height weight
# 1  2    A     NA      2
# 2  4    B     NA      3
# 3  5    C      2      4
# 4  7    D      2      5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;code&gt;poorman&lt;/code&gt;, this type of join can be performed with, you guessed it, &lt;code&gt;right_join()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table1 %&amp;gt;% right_join(table2)
# Joining, by = c(&amp;quot;id&amp;quot;, &amp;quot;name&amp;quot;)
#   id name height weight
# 1  2    A     NA      2
# 2  4    B     NA      3
# 3  5    C      2      4
# 4  7    D      2      5&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;full-join&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Full Join&lt;/h2&gt;
&lt;p&gt;A full join will join together all rows from two tables. Like the left and right joins, any rows that do not contain a match will contain &lt;code&gt;NA&lt;/code&gt; in the cells that are missing. Here we specify &lt;code&gt;all = TRUE&lt;/code&gt; within &lt;code&gt;merge()&lt;/code&gt; to represent a full join.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;merge(x = table1, y = table2, all = TRUE)
#   id name height weight
# 1  1    A      1     NA
# 2  2    A     NA      2
# 3  3    B      2     NA
# 4  4    B     NA      3
# 5  5    C      2      4
# 6  7    D      2      5
# 7  9    E      2     NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally &lt;code&gt;poorman&lt;/code&gt; provides &lt;code&gt;full_join()&lt;/code&gt; to do this type of join.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table1 %&amp;gt;% full_join(table2)
# Joining, by = c(&amp;quot;id&amp;quot;, &amp;quot;name&amp;quot;)
#   id name height weight
# 1  1    A      1     NA
# 2  2    A     NA      2
# 3  3    B      2     NA
# 4  4    B     NA      3
# 5  5    C      2      4
# 6  7    D      2      5
# 7  9    E      2     NA&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;filter-joins&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Filter Joins&lt;/h1&gt;
&lt;p&gt;For filter joins we will look at some slightly different data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table1 &amp;lt;- data.frame(
  pupil = rep(1:3, each = 2),
  test = rep(c(&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;), 3),
  score = c(60, 70, 65, 80, 85, 70),
  stringsAsFactors = FALSE
)
table1
#   pupil test score
# 1     1    A    60
# 2     1    B    70
# 3     2    A    65
# 4     2    B    80
# 5     3    A    85
# 6     3    B    70
table2 &amp;lt;- table1[c(1, 3, 4), ]
table2
#   pupil test score
# 1     1    A    60
# 3     2    A    65
# 4     2    B    80&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;semi-join&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Semi-Join&lt;/h2&gt;
&lt;p&gt;A semi-join is slightly different to the other types of joins we have seen thus far. We describe a semi-join as a “filter join”, since a semi-join returns the rows in &lt;code&gt;table1&lt;/code&gt; where the join column tuples in &lt;code&gt;table1&lt;/code&gt; are also found in &lt;code&gt;table2&lt;/code&gt;. So we still specify the column names that we wish to “join” by (in this example it’s &lt;code&gt;c(&#34;pupil&#34;, &#34;test&#34;)&lt;/code&gt;), which is why this is considered a join but we are actually performing a sort of filter on &lt;code&gt;table1&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;by &amp;lt;- c(&amp;quot;pupil&amp;quot;, &amp;quot;test&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we are looking for the rows in &lt;code&gt;table1&lt;/code&gt; that are also in &lt;code&gt;table2&lt;/code&gt;, we will be using &lt;code&gt;[.data.frame&lt;/code&gt; to filter &lt;code&gt;table1&lt;/code&gt; by the matching rows. To do this, we will take advantage of &lt;code&gt;base::interaction()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;interaction(table1[, by])
# [1] 1.A 1.B 2.A 2.B 3.A 3.B
# Levels: 1.A 2.A 3.A 1.B 2.B 3.B&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, what this function does is compute a vector of factor levels which represents the interaction of the given columns. So the number before the &lt;code&gt;.&lt;/code&gt; is the pupil and the letter after the &lt;code&gt;.&lt;/code&gt; is the test they took. If we do this for both tables, we can figure out which levels are &lt;code&gt;%in%&lt;/code&gt; both tables. As we can see below, the results of &lt;code&gt;%in%&lt;/code&gt; returns a logical vector that we can use to filter &lt;code&gt;table1&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;interaction(table2[, by])
# [1] 1.A 2.A 2.B
# Levels: 1.A 2.A 1.B 2.B
rows &amp;lt;- interaction(table1[, by]) %in% interaction(table2[, by])
rows
# [1]  TRUE FALSE  TRUE  TRUE FALSE FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So here we can see that levels &lt;code&gt;1.A&lt;/code&gt;, &lt;code&gt;2.A&lt;/code&gt; and &lt;code&gt;2.B&lt;/code&gt; appear in both &lt;code&gt;table1&lt;/code&gt; and &lt;code&gt;table2&lt;/code&gt;. So now we can perform our filter.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table1[rows, ]
#   pupil test score
# 1     1    A    60
# 3     2    A    65
# 4     2    B    80&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Semi-join functionality is afforded by &lt;code&gt;poorman&lt;/code&gt; using the &lt;code&gt;semi_join()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table1 %&amp;gt;% semi_join(table2)
# Joining, by = c(&amp;quot;pupil&amp;quot;, &amp;quot;test&amp;quot;, &amp;quot;score&amp;quot;)
#   pupil test score
# 1     1    A    60
# 2     2    A    65
# 3     2    B    80&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;anti-join&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Anti-Join&lt;/h2&gt;
&lt;p&gt;An anti-join is slightly different to a semi-join in that it returns all the rows from &lt;code&gt;table1&lt;/code&gt; that &lt;em&gt;do not&lt;/em&gt; appear in &lt;code&gt;table2&lt;/code&gt; when “joining” on the join columns. Using our previously defined &lt;code&gt;rows&lt;/code&gt; variable, we can take the inverse of this logical vector using &lt;code&gt;!&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rows &amp;lt;- !rows
rows
# [1] FALSE  TRUE FALSE FALSE  TRUE  TRUE
table1[rows, ]
#   pupil test score
# 2     1    B    70
# 5     3    A    85
# 6     3    B    70&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;poorman&lt;/code&gt; provides a copy of anti-join functionality using &lt;code&gt;anti_join()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table1 %&amp;gt;% anti_join(table2)
# Joining, by = c(&amp;quot;pupil&amp;quot;, &amp;quot;test&amp;quot;, &amp;quot;score&amp;quot;)
#   pupil test score
# 1     1    B    70
# 2     3    A    85
# 3     3    B    70&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;As we can see, the join and filter join functionality provided by &lt;code&gt;dplyr&lt;/code&gt; is also available in &lt;code&gt;base&lt;/code&gt;, you just need to know the parameter details or how to perform the filters efficiently. For your convenience, these functions are now available in &lt;code&gt;poorman&lt;/code&gt; using the same &lt;code&gt;dplyr&lt;/code&gt; API: &lt;code&gt;inner_join()&lt;/code&gt;, &lt;code&gt;left_join()&lt;/code&gt;, &lt;code&gt;right_join()&lt;/code&gt;, &lt;code&gt;full_join()&lt;/code&gt;, &lt;code&gt;semi_join()&lt;/code&gt; and &lt;code&gt;anti_join()&lt;/code&gt;. See &lt;code&gt;poorman::joins&lt;/code&gt; or &lt;code&gt;?poorman::filter_joins&lt;/code&gt; for more details.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Building A base dplyr With Primitives: Grouped Operations, Pipes and More!</title>
      <link>/2020/02/27/building-a-base-dplyr-with-primitives-grouped-operations-pipes-and-more/</link>
      <pubDate>Thu, 27 Feb 2020 20:12:00 -0500</pubDate>
      
      <guid>/2020/02/27/building-a-base-dplyr-with-primitives-grouped-operations-pipes-and-more/</guid>
      <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In my &lt;a href=&#34;https://nathaneastwood.github.io/2020/02/15/building-a-base-dplyr-with-primitives/&#34;&gt;last post&lt;/a&gt; we looked at how we can recreate &lt;code&gt;base&lt;/code&gt; equivalents of the &lt;code&gt;dplyr&lt;/code&gt; functions &lt;code&gt;select()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;mutate()&lt;/code&gt; and &lt;code&gt;arrange()&lt;/code&gt;, amongst others. I wrote these functions and presented them in a new package called &lt;a href=&#34;https://github.com/nathaneastwood/poorman&#34;&gt;&lt;code&gt;poorman&lt;/code&gt;&lt;/a&gt;. In this post I will be discussing new functionality that I have since added to &lt;code&gt;poorman&lt;/code&gt; including grouped operations, renaming columns, summarising data and even &lt;code&gt;poorman&lt;/code&gt;’s very own pipe operator!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;group-by&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Group By&lt;/h1&gt;
&lt;div id=&#34;the-base-way&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The &lt;code&gt;base&lt;/code&gt; Way&lt;/h2&gt;
&lt;p&gt;Typically in the past when I have performed grouped operations using &lt;code&gt;base&lt;/code&gt; I have used the tried and tested split-apply-combine approach. That is, I split the &lt;code&gt;data.frame&lt;/code&gt; on a grouping variable, I apply a function and then I combine the parts back together. Let’s take a look at what I mean using the &lt;code&gt;mtcars&lt;/code&gt; dataset by splitting the data into groups representing each combination of transmission type and number of cylinders (see &lt;code&gt;?datasets::mtcars&lt;/code&gt; for more details about this dataset).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Split the data into a list of data.frames - one for each group
split &amp;lt;- split(mtcars, list(mtcars$am, mtcars$cyl))
# Apply the mean function to each data.frame&amp;#39;s mpg column
apply &amp;lt;- lapply(
  split,
  function(x) {
    x[, &amp;quot;meanMpg&amp;quot;] &amp;lt;- mean(x$mpg)
    x
  }
)
# Stitch each of the lists back into one data.frame
combine &amp;lt;- do.call(rbind, unname(apply))
combine
#                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb  meanMpg
# Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 22.90000
# Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 22.90000
# Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1 22.90000
# Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 28.07500
# Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1 28.07500
# Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2 28.07500
# Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1 28.07500
# Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1 28.07500
# Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2 28.07500
# Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2 28.07500
# Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2 28.07500
# Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1 19.12500
# Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1 19.12500
# Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4 19.12500
# Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4 19.12500
# Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4 20.56667
# Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4 20.56667
# Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6 20.56667
# Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2 15.05000
# Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 15.05000
# Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3 15.05000
# Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3 15.05000
# Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3 15.05000
# Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4 15.05000
# Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4 15.05000
# Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4 15.05000
# Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2 15.05000
# AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2 15.05000
# Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4 15.05000
# Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2 15.05000
# Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4 15.40000
# Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8 15.40000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that here I &lt;code&gt;unname()&lt;/code&gt; the list of &lt;code&gt;data.frame&lt;/code&gt;s to avoid &lt;code&gt;rbind()&lt;/code&gt; prepending the row names with the group information. This is a really nice, flexible way to perform grouped operations using &lt;code&gt;base&lt;/code&gt;. There are in fact many other ways that this type of operation can be achieved; the flexibility of &lt;code&gt;base&lt;/code&gt; is what makes it so great.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-poorman-way&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The &lt;code&gt;poorman&lt;/code&gt; Way&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;poorman&lt;/code&gt; aims to be a direct replacement for &lt;code&gt;dplyr&lt;/code&gt;, the idea being that loading &lt;code&gt;poorman&lt;/code&gt; and running your script written with &lt;code&gt;dplyr&lt;/code&gt; code should return the same results. Therefore if you’re familiar with the &lt;code&gt;dplyr&lt;/code&gt; API then the next piece of code should look very familiar.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(poorman)
mtcars %&amp;gt;%
  group_by(am, cyl) %&amp;gt;%
  mutate(meanMpg = mean(mpg))
#                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb  meanMpg
# Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 22.90000
# Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 22.90000
# Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1 22.90000
# Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 28.07500
# Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1 28.07500
# Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2 28.07500
# Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1 28.07500
# Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1 28.07500
# Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2 28.07500
# Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2 28.07500
# Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2 28.07500
# Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1 19.12500
# Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1 19.12500
# Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4 19.12500
# Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4 19.12500
# Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4 20.56667
# Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4 20.56667
# Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6 20.56667
# Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2 15.05000
# Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 15.05000
# Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3 15.05000
# Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3 15.05000
# Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3 15.05000
# Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4 15.05000
# Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4 15.05000
# Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4 15.05000
# Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2 15.05000
# AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2 15.05000
# Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4 15.05000
# Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2 15.05000
# Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4 15.40000
# Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8 15.40000
# 
# Groups:  am, cyl&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to achieve this, I need to have a way to perform grouped operations for functions such as &lt;code&gt;mutate()&lt;/code&gt; and &lt;code&gt;filter()&lt;/code&gt;. The easiest solution I could think of therefore is an S3 class system. So the &lt;code&gt;group_by()&lt;/code&gt; function simply applies a &lt;code&gt;&#34;grouped_data&#34;&lt;/code&gt; class to the data and then the &lt;code&gt;mutate()&lt;/code&gt; S3 generic knows to dispatch to the &lt;code&gt;mutate.grouped_data()&lt;/code&gt; method. For more information on the S3 class system I recommend checking out &lt;a href=&#34;https://adv-r.hadley.nz/s3.html&#34;&gt;Advanced R&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ungrouping&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Ungrouping&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;poorman&lt;/code&gt; also offers a replica of the &lt;code&gt;dplyr::ungroup()&lt;/code&gt; function. Let’s take a look.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;%
  group_by(am, cyl) %&amp;gt;%
  mutate(meanMpg = mean(mpg)) %&amp;gt;%
  ungroup(am)
#                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb  meanMpg
# Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 22.90000
# Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 22.90000
# Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1 22.90000
# Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 28.07500
# Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1 28.07500
# Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2 28.07500
# Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1 28.07500
# Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1 28.07500
# Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2 28.07500
# Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2 28.07500
# Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2 28.07500
# Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1 19.12500
# Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1 19.12500
# Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4 19.12500
# Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4 19.12500
# Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4 20.56667
# Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4 20.56667
# Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6 20.56667
# Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2 15.05000
# Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 15.05000
# Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3 15.05000
# Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3 15.05000
# Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3 15.05000
# Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4 15.05000
# Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4 15.05000
# Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4 15.05000
# Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2 15.05000
# AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2 15.05000
# Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4 15.05000
# Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2 15.05000
# Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4 15.40000
# Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8 15.40000
# 
# Groups:  cyl&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We see here that the printing method tells us the remaining group: &lt;code&gt;cyl&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;additional-functionality&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Additional Functionality&lt;/h1&gt;
&lt;div id=&#34;the-pipe&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The Pipe&lt;/h2&gt;
&lt;p&gt;You will have noticed that I am piping commands together in the above section, however I am not using the &lt;code&gt;magrittr&lt;/code&gt; pipe. I implemented my own version which is a very small piece of code. This means users no longer need to load &lt;code&gt;magrittr&lt;/code&gt; separately (previously &lt;code&gt;poorman&lt;/code&gt; only had &lt;code&gt;magrittr&lt;/code&gt; as a suggested package so as not to force the installation on users).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;`%&amp;gt;%` &amp;lt;- function(lhs, rhs) {
  lhs &amp;lt;- substitute(lhs)
  rhs &amp;lt;- substitute(rhs)
  eval(as.call(c(rhs[[1L]], lhs, as.list(rhs[-1L]))), envir = parent.frame())
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;rename&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Rename&lt;/h2&gt;
&lt;p&gt;I also managed to add &lt;code&gt;rename()&lt;/code&gt;. For this I took advantage of &lt;code&gt;colnames&amp;lt;-&lt;/code&gt; in combination with the &lt;code&gt;inset()&lt;/code&gt; function I defined in my last post (&lt;code&gt;[&amp;lt;-&lt;/code&gt;). I don’t want to make this post too heavy on the code so feel free to take a look at the &lt;a href=&#34;https://github.com/nathaneastwood/poorman/blob/master/R/rename.R&#34;&gt;code&lt;/a&gt; yourself to see how exactly I achieved this.&lt;/p&gt;
&lt;p&gt;Now I am able to pass key-value pairs of unquoted column names to rename columns. See below for an example.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;%
  rename(MPG = mpg, numCyls = cyl)
#                      MPG numCyls  disp  hp drat    wt  qsec vs am gear carb
# Mazda RX4           21.0       6 160.0 110 3.90 2.620 16.46  0  1    4    4
# Mazda RX4 Wag       21.0       6 160.0 110 3.90 2.875 17.02  0  1    4    4
# Datsun 710          22.8       4 108.0  93 3.85 2.320 18.61  1  1    4    1
# Hornet 4 Drive      21.4       6 258.0 110 3.08 3.215 19.44  1  0    3    1
# Hornet Sportabout   18.7       8 360.0 175 3.15 3.440 17.02  0  0    3    2
# Valiant             18.1       6 225.0 105 2.76 3.460 20.22  1  0    3    1
# Duster 360          14.3       8 360.0 245 3.21 3.570 15.84  0  0    3    4
# Merc 240D           24.4       4 146.7  62 3.69 3.190 20.00  1  0    4    2
# Merc 230            22.8       4 140.8  95 3.92 3.150 22.90  1  0    4    2
# Merc 280            19.2       6 167.6 123 3.92 3.440 18.30  1  0    4    4
# Merc 280C           17.8       6 167.6 123 3.92 3.440 18.90  1  0    4    4
# Merc 450SE          16.4       8 275.8 180 3.07 4.070 17.40  0  0    3    3
# Merc 450SL          17.3       8 275.8 180 3.07 3.730 17.60  0  0    3    3
# Merc 450SLC         15.2       8 275.8 180 3.07 3.780 18.00  0  0    3    3
# Cadillac Fleetwood  10.4       8 472.0 205 2.93 5.250 17.98  0  0    3    4
# Lincoln Continental 10.4       8 460.0 215 3.00 5.424 17.82  0  0    3    4
# Chrysler Imperial   14.7       8 440.0 230 3.23 5.345 17.42  0  0    3    4
# Fiat 128            32.4       4  78.7  66 4.08 2.200 19.47  1  1    4    1
# Honda Civic         30.4       4  75.7  52 4.93 1.615 18.52  1  1    4    2
# Toyota Corolla      33.9       4  71.1  65 4.22 1.835 19.90  1  1    4    1
# Toyota Corona       21.5       4 120.1  97 3.70 2.465 20.01  1  0    3    1
# Dodge Challenger    15.5       8 318.0 150 2.76 3.520 16.87  0  0    3    2
# AMC Javelin         15.2       8 304.0 150 3.15 3.435 17.30  0  0    3    2
# Camaro Z28          13.3       8 350.0 245 3.73 3.840 15.41  0  0    3    4
# Pontiac Firebird    19.2       8 400.0 175 3.08 3.845 17.05  0  0    3    2
# Fiat X1-9           27.3       4  79.0  66 4.08 1.935 18.90  1  1    4    1
# Porsche 914-2       26.0       4 120.3  91 4.43 2.140 16.70  0  1    5    2
# Lotus Europa        30.4       4  95.1 113 3.77 1.513 16.90  1  1    5    2
# Ford Pantera L      15.8       8 351.0 264 4.22 3.170 14.50  0  1    5    4
# Ferrari Dino        19.7       6 145.0 175 3.62 2.770 15.50  0  1    5    6
# Maserati Bora       15.0       8 301.0 335 3.54 3.570 14.60  0  1    5    8
# Volvo 142E          21.4       4 121.0 109 4.11 2.780 18.60  1  1    4    2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this function, I was able to implement key-value &lt;code&gt;select()&lt;/code&gt; statements too!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;%
  select(MPG = mpg, numCyls = cyl, numGears = gear)
#                      MPG numCyls numGears
# Mazda RX4           21.0       6        4
# Mazda RX4 Wag       21.0       6        4
# Datsun 710          22.8       4        4
# Hornet 4 Drive      21.4       6        3
# Hornet Sportabout   18.7       8        3
# Valiant             18.1       6        3
# Duster 360          14.3       8        3
# Merc 240D           24.4       4        4
# Merc 230            22.8       4        4
# Merc 280            19.2       6        4
# Merc 280C           17.8       6        4
# Merc 450SE          16.4       8        3
# Merc 450SL          17.3       8        3
# Merc 450SLC         15.2       8        3
# Cadillac Fleetwood  10.4       8        3
# Lincoln Continental 10.4       8        3
# Chrysler Imperial   14.7       8        3
# Fiat 128            32.4       4        4
# Honda Civic         30.4       4        4
# Toyota Corolla      33.9       4        4
# Toyota Corona       21.5       4        3
# Dodge Challenger    15.5       8        3
# AMC Javelin         15.2       8        3
# Camaro Z28          13.3       8        3
# Pontiac Firebird    19.2       8        3
# Fiat X1-9           27.3       4        4
# Porsche 914-2       26.0       4        5
# Lotus Europa        30.4       4        5
# Ford Pantera L      15.8       8        5
# Ferrari Dino        19.7       6        5
# Maserati Bora       15.0       8        5
# Volvo 142E          21.4       4        4&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;summary&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Finally I have added a copy of the &lt;code&gt;summarise()&lt;/code&gt; function. This was probably the trickiest piece of code to write for the package and I am not completely satisfied with my solution although it works and is seemingly quite quick (on my 2016 MacBook Pro). If you’re interested in taking a look at the implementation and making suggestions then the code can be found &lt;a href=&#34;https://github.com/nathaneastwood/poorman/blob/master/R/summarise.R&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;%
  group_by(am, cyl) %&amp;gt;%
  summarise(meanMpg = mean(mpg), sumDisp = sum(disp))
#   am cyl  meanMpg sumDisp
# 1  0   4     22.9   407.6
# 2  1   4   28.075   748.9
# 3  0   6   19.125   818.2
# 4  1   6 20.56667     465
# 5  0   8    15.05  4291.4
# 6  1   8     15.4     652&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Recently there was a very interesting Twitter discussion on this topic which led to an comprehensive list of examples for performing this operation in &lt;code&gt;base&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet tw-align-center&#34;&gt;
&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;
How would you write this in base R?&lt;br&gt;&lt;br&gt;mtcars %&amp;gt;% &lt;br&gt; group_by(cyl) %&amp;gt;% &lt;br&gt; summarise(mean = mean(disp), n = n())&lt;br&gt;&lt;br&gt;I&#39;ve written up three approaches in &lt;a href=&#34;https://t.co/BBnXSDSf67&#34;&gt;https://t.co/BBnXSDSf67&lt;/a&gt;. Is there a better way? &lt;a href=&#34;https://twitter.com/hashtag/rstats?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#rstats&lt;/a&gt;
&lt;/p&gt;
— Hadley Wickham (&lt;span class=&#34;citation&#34;&gt;@hadleywickham&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/hadleywickham/status/1231252596712771585?ref_src=twsrc%5Etfw&#34;&gt;February 22, 2020&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;I believe that &lt;code&gt;poorman&lt;/code&gt; now offers the core of what &lt;code&gt;dplyr&lt;/code&gt; has to offer using only &lt;code&gt;base&lt;/code&gt;, therefore zero dependencies (not including development based dependencies such as &lt;code&gt;roxygen2&lt;/code&gt;). I now need to really start writing some serious tests which I will endeavour to do using &lt;a href=&#34;https://github.com/markvanderloo/tinytest&#34;&gt;&lt;code&gt;tinytest&lt;/code&gt;&lt;/a&gt; before adding any additional functionality. Without tests, any package is rather worthless in my opinion. If there is functionality you would like to see added to the package then please feel free to submit an issue or open a pull request.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Building A base dplyr With Primitives</title>
      <link>/2020/02/15/building-a-base-dplyr-with-primitives/</link>
      <pubDate>Sat, 15 Feb 2020 20:12:00 -0500</pubDate>
      
      <guid>/2020/02/15/building-a-base-dplyr-with-primitives/</guid>
      <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In one of my &lt;a href=&#34;https://nathaneastwood.github.io/2020/02/01/get-and-set-list-elements-with-magrittr/&#34;&gt;latest posts&lt;/a&gt;, I discussed the idea of turning base R’s get and set operators (&lt;code&gt;[&lt;/code&gt;, &lt;code&gt;[[&lt;/code&gt;, &lt;code&gt;[&amp;lt;-&lt;/code&gt;, &lt;code&gt;[[&amp;lt;-&lt;/code&gt;) into human readable and pipeable functions. It was kindly pointed out in the comments that the &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;set()&lt;/code&gt; functions I defined in that blog post are actually exported in the &lt;code&gt;magrittr&lt;/code&gt; package as &lt;code&gt;magrittr::extract2()&lt;/code&gt; (&lt;code&gt;[[&lt;/code&gt;) and &lt;code&gt;magrittr::inset2()&lt;/code&gt; (&lt;code&gt;[[&amp;lt;-&lt;/code&gt;). In fact, there are a whole host of “alias” functions exported by &lt;code&gt;magrittr&lt;/code&gt;, see &lt;code&gt;?magrittr::extract2&lt;/code&gt; for more. However if we are developing a package, we may not necessarily want to &lt;code&gt;Import: magrittr&lt;/code&gt;, we may only want to &lt;code&gt;Suggest&lt;/code&gt; it as a package that complements our package. This is especially true when the functions we will be importing are simple aliases of other functions that we can just as easily create ourselves. Now sure, a lot of people already have and use &lt;code&gt;magrittr&lt;/code&gt;, in which case they can use it, but not everyone wants it or uses it, so we shouldn’t enforce that dependency on users.&lt;/p&gt;
&lt;p&gt;Take for example if we were to create a package that recreates &lt;code&gt;dplyr&lt;/code&gt;’s main verbs, &lt;code&gt;select()&lt;/code&gt;; &lt;code&gt;filter()&lt;/code&gt;; &lt;code&gt;mutate()&lt;/code&gt;; and &lt;code&gt;arrange()&lt;/code&gt;, using base R only. Think of it as a “poor man’s” dplyr, of course I jest - &lt;code&gt;base&lt;/code&gt; is awesome. Oftentimes the main complaint I hear about &lt;code&gt;dplyr&lt;/code&gt; is the sheer number of dependencies it has and the installation times that come with that; not to mention APIs have changed a few times over the years. &lt;code&gt;base&lt;/code&gt; on the other hand already comes pre-installed with R and the API is extremely stable. The reason people like &lt;code&gt;dplyr&lt;/code&gt;, however, is because the API on offer is extremely flexible and easy to understand. This blog post will show how we can recreate these verbs using base R and aliases to R’s operator functions and use them in conjunction with &lt;code&gt;magrittr&lt;/code&gt;.&lt;/p&gt;
&lt;div id=&#34;select&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Select&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dplyr::select()&lt;/code&gt; allows the user to subset the columns of a &lt;code&gt;data.frame&lt;/code&gt; and always return a &lt;code&gt;data.frame&lt;/code&gt;. Thus to recreate this function we will need the operator for subsetting columns of a &lt;code&gt;data.frame&lt;/code&gt; which is &lt;code&gt;[&lt;/code&gt;, or more specifically, &lt;code&gt;[.data.frame&lt;/code&gt;. Let’s take a look at the arguments for this function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;args(`[.data.frame`)
# function (x, i, j, drop = if (missing(i)) TRUE else length(cols) == 
#     1) 
# NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We see that it takes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; - the &lt;code&gt;data.frame&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; - the rows to subset&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j&lt;/code&gt; - the columns to subset&lt;/li&gt;
&lt;li&gt;&lt;code&gt;drop&lt;/code&gt; - whether to return a vector if only one column is left&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will define our wrapper for the &lt;code&gt;[&lt;/code&gt; function in the same way that &lt;code&gt;magrittr&lt;/code&gt; does.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;extract &amp;lt;- `[`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As this is an S3 generic, R will know to dispatch to &lt;code&gt;[.data.frame&lt;/code&gt; when it is passed a &lt;code&gt;data.frame&lt;/code&gt;. Hence, we can now define a &lt;code&gt;select()&lt;/code&gt; function which is similar in functionality to that of &lt;code&gt;dplyr::select()&lt;/code&gt;. Note that we tell R that we wish to subset all of the rows in the &lt;code&gt;i&lt;/code&gt; position by leaving the argument blank.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select &amp;lt;- function(.data, ...) {
  cols &amp;lt;- vapply(substitute(...()), deparse, NA_character_)
  extract(.data, , cols, drop = FALSE)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function uses a couple of tricks here, so I’ll break them down. To use non-standard evaluation in the same way that &lt;code&gt;dplyr&lt;/code&gt; does, that is to pass non-quoted column names, we must deparse them. We loop over the columns passed via &lt;code&gt;...&lt;/code&gt; using a &lt;code&gt;vapply()&lt;/code&gt;. The &lt;code&gt;substitute(...())&lt;/code&gt; gives us a list-like object of all the symbols we pass which we can loop over. Using this function, we can now select a single column.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% select(mpg)
#                      mpg
# Mazda RX4           21.0
# Mazda RX4 Wag       21.0
# Datsun 710          22.8
# Hornet 4 Drive      21.4
# Hornet Sportabout   18.7
# Valiant             18.1
# Duster 360          14.3
# Merc 240D           24.4
# Merc 230            22.8
# ... 23 rows omitted&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or multiple columns by passing a vector.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% select(mpg, cyl)
#                      mpg cyl
# Mazda RX4           21.0   6
# Mazda RX4 Wag       21.0   6
# Datsun 710          22.8   4
# Hornet 4 Drive      21.4   6
# Hornet Sportabout   18.7   8
# Valiant             18.1   6
# Duster 360          14.3   8
# Merc 240D           24.4   4
# Merc 230            22.8   4
# ... 23 rows omitted&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course, this function works without &lt;code&gt;magrittr&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select(mtcars, mpg, cyl)
#                      mpg cyl
# Mazda RX4           21.0   6
# Mazda RX4 Wag       21.0   6
# Datsun 710          22.8   4
# Hornet 4 Drive      21.4   6
# Hornet Sportabout   18.7   8
# Valiant             18.1   6
# Duster 360          14.3   8
# Merc 240D           24.4   4
# Merc 230            22.8   4
# ... 23 rows omitted&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For bonus points, we can write an equivalent of &lt;code&gt;dplyr::pull()&lt;/code&gt; by setting the &lt;code&gt;drop = TRUE&lt;/code&gt; argument and removing the &lt;code&gt;cols&lt;/code&gt; parameter since we are only dealing with one column.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pull &amp;lt;- function(.data, var) {
  var &amp;lt;- deparse(substitute(var))
  stopifnot(length(var) == 1)
  extract(.data, , var, drop = TRUE)
}
mtcars %&amp;gt;% pull(mpg)
#  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 10.4 14.7
# [18] 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7 15.0 21.4&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;filter&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Filter&lt;/h2&gt;
&lt;p&gt;As we saw in the previous section, &lt;code&gt;[.data.frame&lt;/code&gt; takes &lt;code&gt;i&lt;/code&gt; as an argument which represents the rows to filter. Thus we can use a similar method to that used for &lt;code&gt;select()&lt;/code&gt; only in this case, we must build the expressions by which to filter and separate them with an ampersand from which we can parse and evaluate.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter &amp;lt;- function(.data, ...) {
  conditions &amp;lt;- paste(vapply(substitute(...()), deparse, NA_character_), collapse = &amp;quot; &amp;amp; &amp;quot;)
  extract(.data, with(.data, eval(parse(text = conditions))), )
}
mtcars %&amp;gt;% filter(cyl == 4)
#                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb
# Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
# Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
# Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
# Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
# Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
# Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
# Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
# Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
# Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
# ... 2 rows omitted
mtcars %&amp;gt;% filter(cyl &amp;lt;= 5 &amp;amp; am &amp;gt; 0)
#                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb
# Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
# Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
# Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
# Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
# Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
# Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
# Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
# Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
mtcars %&amp;gt;% filter(cyl == 4 | cyl == 8)
#                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb
# Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
# Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
# Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
# Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
# Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
# Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
# Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
# Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
# Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
# ... 16 rows omitted
mtcars %&amp;gt;% filter(!(cyl %in% c(4, 6)), am != 0)
#                 mpg cyl disp  hp drat   wt qsec vs am gear carb
# Ford Pantera L 15.8   8  351 264 4.22 3.17 14.5  0  1    5    4
# Maserati Bora  15.0   8  301 335 3.54 3.57 14.6  0  1    5    8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also get a copy of &lt;code&gt;dplyr::slice()&lt;/code&gt; really cheaply.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;slice &amp;lt;- function(.data, ...) {
  stopifnot(is.numeric(...) || is.integer(...))
  extract(.data, ..., )
}
mtcars %&amp;gt;% slice(1:3)
#                mpg cyl disp  hp drat    wt  qsec vs am gear carb
# Mazda RX4     21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
# Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
# Datsun 710    22.8   4  108  93 3.85 2.320 18.61  1  1    4    1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;arrange&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Arrange&lt;/h2&gt;
&lt;p&gt;The final function using the &lt;code&gt;extract()&lt;/code&gt; alias that I want to highlight is &lt;code&gt;arrange()&lt;/code&gt;. I want to highlight this function because of the required trick with &lt;code&gt;eval.parent()&lt;/code&gt; (note there are &lt;a href=&#34;https://stackoverflow.com/a/58757430/3759418&#34;&gt;other ways&lt;/a&gt; we could achieve this).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;arrange &amp;lt;- function(.data, ...) {
  rows &amp;lt;- eval.parent(substitute(with(.data, order(...))))
  extract(.data, rows, , drop = FALSE)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use &lt;code&gt;eval.parent()&lt;/code&gt; instead of &lt;code&gt;eval()&lt;/code&gt;, because the &lt;a href=&#34;https://stackoverflow.com/a/53215820/300187&#34;&gt;&lt;code&gt;eval()&lt;/code&gt;/&lt;code&gt;substitute()&lt;/code&gt; combo doesn’t play well with nested functions&lt;/a&gt;. The &lt;code&gt;eval.parent()&lt;/code&gt; trick has been &lt;a href=&#34;https://stackoverflow.com/a/58239679/300187&#34;&gt;proposed by @MoodyMudskipper&lt;/a&gt; as a way to address this problem and allows us to seamlessly use &lt;code&gt;arrange()&lt;/code&gt; inside other functions, including &lt;code&gt;magrittr&lt;/code&gt; pipes:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% arrange(mpg)
#                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb
# Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
# Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
# Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
# Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
# Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
# Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
# Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
# AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
# Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
# ... 23 rows omitted
mtcars %&amp;gt;% arrange(cyl, mpg)
#                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb
# Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
# Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
# Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
# Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
# Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
# Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
# Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
# Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
# Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
# ... 23 rows omitted&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thanks go to Artem Sokolov for &lt;a href=&#34;https://stackoverflow.com/a/58757463/3759418&#34;&gt;pointing this out&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;mutate&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Mutate&lt;/h2&gt;
&lt;p&gt;If we wish to create new columns in our dataset, particularly columns created using existing columns in the data, we must use the &lt;code&gt;[&amp;lt;-&lt;/code&gt; operator, specifically, &lt;code&gt;[&amp;lt;-.data.frame&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;args(`[&amp;lt;-.data.frame`)
# function (x, i, j, value) 
# NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;[&amp;lt;-.data.frame&lt;/code&gt; takes the arguments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; - the data&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; - the rows to create&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j&lt;/code&gt; - the columns to create&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt; - the value to give to the rows/columns&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will assign this operator to &lt;code&gt;inset&lt;/code&gt; - the same as &lt;code&gt;magrittr&lt;/code&gt; does.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;inset &amp;lt;- `[&amp;lt;-`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we &lt;code&gt;lapply()&lt;/code&gt; over each of the conditions to return a list of vectored results of our expressions. We then use the &lt;code&gt;inset()&lt;/code&gt; function to add these vectors as new columns to the &lt;code&gt;data.frame&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mutate &amp;lt;- function(.data, ...) {
  conditions &amp;lt;- vapply(substitute(...()), deparse, NA_character_)
  new_data &amp;lt;- lapply(
    conditions,
    function(x, .data) with(.data, eval(parse(text = x))),
    .data
  )
  inset(.data, , names(conditions), new_data)
}
mtcars %&amp;gt;% mutate(mpg2 = mpg * 2)
#                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb mpg2
# Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4 42.0
# Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4 42.0
# Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 45.6
# Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1 42.8
# Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2 37.4
# Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1 36.2
# Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 28.6
# Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 48.8
# Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 45.6
# ... 23 rows omitted
mtcars %&amp;gt;% mutate(mpg2 = mpg * 2, cyl2 = cyl * 2)
#                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb mpg2 cyl2
# Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4 42.0   12
# Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4 42.0   12
# Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 45.6    8
# Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1 42.8   12
# Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2 37.4   16
# Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1 36.2   12
# Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 28.6   16
# Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 48.8    8
# Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 45.6    8
# ... 23 rows omitted&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that unlike &lt;code&gt;dplyr::mutate()&lt;/code&gt;, we cannot create columns based on expressions we pass, for example, the following would not work.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% mutate(mpg2 = mpg * 2, mpg3 = mpg2 * 3)
# Error in eval(parse(text = x)): object &amp;#39;mpg2&amp;#39; not found&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a bonus, we can combine our &lt;code&gt;mutate()&lt;/code&gt; function with &lt;code&gt;extract()&lt;/code&gt; to create a copy of &lt;code&gt;dplyr::transmute()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;transmute &amp;lt;- function(.data, ...) {
  conditions &amp;lt;- vapply(substitute(...()), deparse, NA_character_)
  mutated &amp;lt;- mutate(.data, ...)
  extract(mutated, names(conditions))
}
mtcars %&amp;gt;% transmute(mpg2 = mpg * 2, cyl2 = cyl * 2)
#                     mpg2 cyl2
# Mazda RX4           42.0   12
# Mazda RX4 Wag       42.0   12
# Datsun 710          45.6    8
# Hornet 4 Drive      42.8   12
# Hornet Sportabout   37.4   16
# Valiant             36.2   12
# Duster 360          28.6   16
# Merc 240D           48.8    8
# Merc 230            45.6    8
# ... 23 rows omitted&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;chaining&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Chaining&lt;/h2&gt;
&lt;p&gt;As a final note, it should be clear that due to the nature of &lt;code&gt;magrittr&lt;/code&gt;, your standard chaining of functions will still work.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
  filter(cyl == 4) %&amp;gt;%
  select(mpg, cyl, wt, disp)
#                 mpg cyl    wt  disp
# Datsun 710     22.8   4 2.320 108.0
# Merc 240D      24.4   4 3.190 146.7
# Merc 230       22.8   4 3.150 140.8
# Fiat 128       32.4   4 2.200  78.7
# Honda Civic    30.4   4 1.615  75.7
# Toyota Corolla 33.9   4 1.835  71.1
# Toyota Corona  21.5   4 2.465 120.1
# Fiat X1-9      27.3   4 1.935  79.0
# Porsche 914-2  26.0   4 2.140 120.3
# ... 2 rows omitted&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The idea behind this blog post was to highlight how we can use more human readable versions of R’s primitive operators to aid in pipeable data manipulation functions. Of course the solutions provided in this blog post are over-engineered and you would probably write them in a different way if you were seriously thinking about releasing them as a package. Also, whilst these functions are available via an import of &lt;code&gt;magrittr&lt;/code&gt;, you may not wish to force the user to import &lt;code&gt;magrittr&lt;/code&gt; and may wish to keep it as a suggestion instead. This reduces the number of dependencies on your package.&lt;/p&gt;
&lt;p&gt;For what it’s worth, I have included all of the above code in a package called &lt;a href=&#34;https://github.com/nathaneastwood/poorman&#34;&gt;&lt;code&gt;poorman&lt;/code&gt;&lt;/a&gt; on my GitHub account. These functions haven’t been thoroughly tested and there may well be bugs. There are, however, much more detailed and dedicated recreations of &lt;code&gt;dplyr&lt;/code&gt; using base R. If you are interested, check out: &lt;a href=&#34;https://github.com/yonicd/bplyr&#34;&gt;&lt;code&gt;bplyr&lt;/code&gt;&lt;/a&gt; (note this package uses &lt;code&gt;rlang&lt;/code&gt;) and &lt;a href=&#34;https://github.com/mkearney/tbltools&#34;&gt;&lt;code&gt;tbltools&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>